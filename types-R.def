
GRAPH:
    INCONV: if (!is.igraph(%I%)) { stop("Not a graph object") }

GRAPH_OR_0:    
    INCONV: if (!is.igraph(%I%)) { stop("Not a graph object") }

INTEGER:
    INCONV: %I% <- as.numeric(%I%)

REAL:
    INCONV: %I% <- as.numeric(%I%)

BOOLEAN:
    INCONV: %I% <- as.logical(%I%)
    DEFAULT:
       True: TRUE
       False: FALSE

VECTOR:
    INCONV: %I% <- as.numeric(%I%)

VECTOR_OR_0:
    INCONV: if (!is.null(%I%)) %I% <- as.numeric(%I%)

VECTOR_BOOL:
    INCONV: %I% <- as.logical(%I%)

VECTOR_BOOL_OR_0:
    INCONV: if (!is.null(%I%)) %I% <- as.logical(%I%)

MATRIX:
    INCONV: %I% <- structure(as.double(%I%), dim=dim(%I%))

MATRIX_OR_0:
    INVONV: if (!is.null(%I%)) %I% <- structure(as.double(%I%), dim=dim(%I%))

ARRAY3:
    INCONV: %I% <- structure(as.double(%I%), dim=dim(%I%))

ARRAY3_OR_0:
    INCONV: if (!is.null(%I%)) %I% <- structure(as.double(%I%), dim=dim(%I%))

ATTRIBUTES:

SCG_MATRIX:
    INCONV: %I% <- switch(igraph.match.arg(%I%), "symmetric"=1, "laplacian"=2, "stochastic="=3)
    DEFAULT:
       SYMMETRIC: c("symmetric", "laplacian", "stochastic")

SCG_ALGO:
    INCONV: %I% <- switch(igraph.match.arg(%I%), "optimum"=1, "interv_km"=2, "interv"=3, "exact"=4)
    DEFAULT:
       OPTIMUM: c("optimum", "interv_km", "interv", "exact")

SCG_NORM:
    INCONV: %I% <- switch(igraph.match.arg(%I%), "row"=0, "col"=1)
    DEFAULT:
      ROW: c("row", "col")

SCG_DIRECTION: 
    INCONV: %I% <- switch(igraph.match.arg(%I%), "default"=0, "right"=1, "left"=2)
    DEFAULT:
      DEFAULT: c("default", "right", "left")

CONNECTEDNESS:
    INCONV: %I% <- switch(igraph.match.arg(%I%), "weak"=1, "strong"=2)
    DEFAULT:
       WEAK: c("weak", "strong")

NEIMODE:
    INCONV: %I% <- switch(igraph.match.arg(%I%), "out"=1, "in"=2, "all"=3, "total"=3)
    DEFAULT:
       ALL: c("all", "out", "in", "total")
       TOTAL: c("total", "out", "in", "all")
       OUT: c("out", "in", "all", "total")
       IN: c("in", "out", "all", "total")

INTEGERPTR:
    INCONV:
       INOUT: %I% <- as.numeric(%I%)

BOOLEANPTR:

BOOLEANPTR_OR_0:    

REALPTR:
    INCONV:
       INOUT: %I% <- as.numeric(%I%)

INT:
    INCONV: %I% <- as.integer(%I%)

VERTEXSET:
    INCONV: %I% <- as.igraph.vs(%I%)
    DEFAULT:
       ALL: V(%I1%)

EDGESET:
    INCONV: %I% <- as.igraph.es(%I%)
    DEFAULT:
       ALL: E(%I1%)

EDGEWEIGHTS:
    INCONV: if (is.null(%I%) && "weight" %in% list.edge.attributes(%I1%)) { \
               %I% <- E(%I1%)$weight \
            } \
            if (!is.null(%I%) && any(!is.na(%I%))) { \
               %I% <- as.numeric(%I%) \
            } else { \
               %I% <- NULL \
            }

BIPARTITE_TYPES:
    INCONV: if (is.null(%I%) && "type" %in% list.vertex.attributes(%I1%)) { \
               %I% <- V(%I1%)$type \
	    } \
            if (!is.null(%I%)) { \
               %I% <- as.logical(%I%) \
            } else { \
               stop("Not a bipartite graph, supply `types' argument") \
            }

NULL:
    CALL:
    HEADER:

VECTORLIST:

ARPACKOPT:
    INCONV:
      INOUT: %I%.tmp <- igraph.arpack.default; %I%.tmp[ names(%I%) ] <- %I% ; %I% <- %I%.tmp

DRL_OPTIONS:
    INCONV:
      IN: %I%.tmp <- igraph.drl.default; %I%.tmp [names(%I%)] <- %I%; %I% <- %I%.tmp

STRVECTOR:

BLISSSH:
    INCONV: %I% <- switch(igraph.match.arg(%I%), "f"=0, "fl"=1, "fs"=2, "fm"=3, "flm"=4, "fsm"=5)

BLISSINFO:

ADJLIST:
    INCONV: %I% <- lapply(%I%, as.numeric)
