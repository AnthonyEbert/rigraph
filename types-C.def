
##################################
# GRAPH

GRAPH:
  CTYPE: igraph_t
  CALL:  &%C%
  INCONV: 
    IN: R_SEXP_to_igraph(%I%, &%C%);
    INOUT: R_SEXP_to_igraph_copy(%I%, &%C%); \
           IGRAPH_FINALLY(igraph_destroy, &%C%);
  OUTCONV:
    OUT: IGRAPH_FINALLY(igraph_destroy, &%C%); \
         PROTECT(%I%=R_igraph_to_SEXP(&%C%));  \
         igraph_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);
    INOUT: PROTECT(%I%=R_igraph_to_SEXP(&%C%));  \
           igraph_destroy(&%C%); \
           IGRAPH_FINALLY_CLEAN(1);

##################################
# INTEGER

INTEGER:  
  CTYPE: igraph_integer_t
  INCONV: 
    IN: %C%=REAL(%I%)[0];
  OUTCONV:
    OUT: PROTECT(%I%=NEW_NUMERIC(1)); \
         REAL(%I%)[0]=%C%;

INTEGERPTR:
  CTYPE: igraph_integer_t
  CALL: &%C%
  OUTCONV:
    OUT: PROTECT(%I%=NEW_NUMERIC(1)); \
         REAL(%I%)[0]=%C%;

INT:
  CTYPE: int
  INCONV:
    IN: %C%=INTEGER(%I%)[0];

##################################
# REAL

REAL:
  CTYPE: igraph_real_t
  INCONV:
    IN: %C%=REAL(%I%)[0];

REALPTR:
  CTYPE: igraph_real_t
  CALL: &%C%
  INCONV:
    INOUT: %C%=REAL(%I%)[0];
  OUTCONV:
    OUT: PROTECT(%I%=NEW_NUMERIC(1)); \
         REAL(%I%)[0]=%C%;
    INOUT: PROTECT(%I%=NEW_NUMERIC(1)); \
         REAL(%I%)[0]=%C%;

##################################
# BOOLEAN

BOOLEAN:
  CTYPE: igraph_bool_t
  INCONV:
    IN: %C%=LOGICAL(%I%)[0];
  OUTCONV:
    OUT: PROTECT(%I%=NEW_LOGICAL(1)); \
         LOGICAL(%I%)[0]=%C%;

BOOLEANPTR:
  CTYPE: igraph_bool_t
  CALL: &%C%
  OUTCONV:
    OUT: PROTECT(%I%=NEW_LOGICAL(1)); \
         LOGICAL(%I%)[0]=%C%;

##################################
# ERROR, used as the return type usually

ERROR:
  CTYPE: int

##################################
# CONNECTEDNESS

CONNECTEDNESS:
  CTYPE: igraph_connectedness_t
  INCONV:
    IN: %C%=REAL(%I%)[0];

NEIMODE:
  CTYPE: igraph_integer_t
  INCONV:
    IN: %C%=REAL(%I%)[0];

##################################
# VECTOR of real values

VECTOR:
  CTYPE: igraph_vector_t
  CALL: &%C%
  INCONV:
    IN: R_SEXP_to_vector(%I%, &%C%);
    OUT: if (0 != igraph_vector_init(&%C%, 0)) { \
           igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(igraph_vector_destroy, &%C%);
    INOUT: if (0 != R_SEXP_to_vector_copy(%I%, &%C%)) { \
           igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(igraph_vector_destroy, &%C%);
  OUTCONV:
    OUT: PROTECT(%I%=R_igraph_vector_to_SEXP(&%C%)); \
         igraph_vector_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);
    INOUT: PROTECT(%I%=R_igraph_vector_to_SEXP(&%C%)); \
         igraph_vector_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);

VECTORLIST:
  CTYPE: igraph_vector_ptr_t
  CALL: &%C%
  INCONV:
    OUT: if (0 != igraph_vector_ptr_init(&%C%, 0)) { \
           igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(R_igraph_vectorlist_destroy, &%C%);
  OUTCONV:
    OUT: PROTECT(%I%=R_igraph_vectorlist_to_SEXP(&%C%)); \
         R_igraph_vectorlist_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);

##################################
# VECTOR that can be NULL
# 'OUT' arguments are always returned now, in the 
# future we should have a boolean R argument for them which
# defines whether or not we want to return them, but this 
# requires some stimulus development.

VECTOR_OR_0:
  CTYPE: igraph_vector_t
  CALL: (isNull(%I%) ? 0 : &%C%)
  INCONV:
    IN: if (!isNull(%I%)) { R_SEXP_to_vector(%I%, &%C%); }
    OUT: if (0 != igraph_vector_init(&%C%, 0)) { \
           igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(igraph_vector_destroy, &%C%); \
         %I%=NEW_NUMERIC(0); /* hack to have a non-NULL value */
  OUTCONV:
    OUT: PROTECT(%I%=R_igraph_0orvector_to_SEXP(&%C%)); \
         igraph_vector_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);

# This is the same, some syntax would be needed to express it

EDGEWEIGHTS:
  CTYPE: igraph_vector_t
  CALL: (isNull(%I%) ? 0 : &%C%)
  INCONV:
    IN: if (!isNull(%I%)) { R_SEXP_to_vector(%I%, &%C%); }
    OUT: if (0 != igraph_vector_init(&%C%, 0)) { \
           igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(igraph_vector_destroy, &%C%); \
         %I%=NEW_NUMERIC(0); /* hack to have a non-NULL value */
  OUTCONV:
    OUT: PROTECT(%I%=R_igraph_0orvector_to_SEXP(&%C%)); \
         igraph_vector_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);

##################################
# MATRIX of real values

MATRIX:
  CTYPE: igraph_matrix_t
  CALL: &%C%
  INCONV:
    IN: R_SEXP_to_matrix(%I%, &%C%);
    OUT: if (0 != igraph_matrix_init(&%C%, 0, 0)) { \
            igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(igraph_matrix_destroy, &%C%);
  OUTCONV:
    OUT: PROTECT(%I%=R_igraph_matrix_to_SEXP(&%C%)); \
         igraph_matrix_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);

MATRIX_OR_0:
  CTYPE: igraph_matrix_t
  CALL: (isNull(%I%) ? 0 : &%C%)
  INCONV:
    IN: if (!isNull(%I%)) { R_SEXP_to_matrix(%I%, &%C%); }
    OUT: if (0 != igraph_matrix_init(&%C%, 0, 0)) { \
           igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(igraph_matrix_destroy, &%C%); \
         %I%=NEW_NUMERIC(0); /* hack to have a non-NULL value */
  OUTCONV:
    OUT: PROTECT(%I%=R_igraph_0ormatrix_to_SEXP(&%C%)); \
         igraph_matrix_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);

##################################
# 3d array

ARRAY3:
  CTYPE: igraph_array3_t
  CALL: &%C%
  INCONV:
    IN: R_igraph_SEXP_to_array3(%I%, &%C%);
    OUT: if (0 != igraph_array3_init(&%C%, 0, 0, 0)) { \
           igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(igraph_array3_destroy, &%C%);
  OUTCONV:
    OUT: PROTECT(%I%=R_igraph_array3_to_SEXP(&%C%)); \
         igraph_array3_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);

ARRAY3_OR_0:
  CTYPE: igraph_array3_t
  CALL: (isNull(%I%) ? 0 : &%C%)
  INCONV:
    IN: if (!isNull(%I%)) { R_igraph_SEXP_to_array3(%I%, &%C%); }
    OUT: if (0 != igraph_array3_init(&%C%, 0, 0, 0)) { \
            igraph_error("", __FILE__, __LINE__, IGRAPH_ENOMEM); \
         } \
         IGRAPH_FINALLY(igraph_array3_destroy, &%C%); \
         %I%=NEW_NUMERIC(0); /* hack to have a non-NULL value */
  OUTCONV:
    OUT: PROTECT(%I%=R_igraph_0orarray3_to_SEXP(&%C%)); \
         igraph_array3_destroy(&%C%); \
         IGRAPH_FINALLY_CLEAN(1);

##################################
# 3d array



##################################
# Some vertices of a graph

VERTEXSET:
  CTYPE: igraph_vs_t
  INCONV:
    IN: R_SEXP_to_igraph_vs(%I%, &%C1%, &%C%);
  OUTCONV:
    IN: igraph_vs_destroy(&%C%);

##################################
# NULL, this is supplied as an argument

NULL:
  CALL: 0
  HEADER:

##################################
# Options to the ARPACK solver

ARPACKOPT:
  CTYPE: igraph_arpack_options_t
  CALL: &%C%
  INCONV:
    INOUT: R_SEXP_to_igraph_arpack_options(%I%, &%C%);
  OUTCONV:
    INOUT: PROTECT(%I%=R_igraph_arpack_options_to_SEXP(&%C%));
